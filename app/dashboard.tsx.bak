import React, { useState, useEffect, useMemo, memo } from 'react';
import { View, Text, Dimensions, StyleSheet, Pressable, TouchableOpacity } from 'react-native';
import { useRouter, useFocusEffect } from 'expo-router';
import { Ionicons } from '@expo/vector-icons';
import { useSafeAreaInsets } from 'react-native-safe-area-context';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withTiming,
  Easing,
  interpolate,
  useAnimatedProps,
  type SharedValue,
} from 'react-native-reanimated';
import Svg, { Defs, Path, Circle, LinearGradient, Stop } from 'react-native-svg';
import { StatusBar } from 'expo-status-bar';
import { useVideoPlayer, VideoView } from 'expo-video';

const { width, height } = Dimensions.get('window');

// --- Configuration ---
const PLANET_RADIUS = width * 1.1; 
const PLANET_CENTER_X = width / 2;
const ARC_TOP_Y = height * 0.82;
const PLANET_CENTER_Y = ARC_TOP_Y + PLANET_RADIUS; 

const NAV_ITEMS = [
  { id: 'events', label: 'Events', icon: 'calendar-clear-outline', angle: -18 },
  { id: 'schedule', label: 'Schedule', icon: 'time-outline', angle: -9 },
  { id: 'merch', label: 'Merch', icon: 'cart-outline', angle: 0 },
  { id: 'stay', label: 'Stay', icon: 'bed-outline', angle: 9 },
  { id: 'profile', label: 'Profile', icon: 'person-outline', angle: 18 },
];

const DRAWER_LINKS = [
    { id: 'maps', label: 'Maps', sub: 'NAV' },
    { id: 'epc', label: 'EPC Blog', sub: 'READ' },
    { id: 'hpc', label: 'HPC Blog', sub: 'TECH' },
    { id: 'sponsors', label: 'Sponsors', sub: 'PART' },
    { id: 'contact', label: 'Contact Us', sub: 'COMM' },
    { id: 'developers', label: 'Developers', sub: 'DEV' },
];

const THEME = {
  bg: '#0E0929',       
  path: '#92ACFF',     
  text: '#ffffff',
  secondary: 'rgba(146, 172, 255, 0.5)',
  accent: '#92ACFF',
  pink: '#FF6B9D',
  dim: 'rgba(146, 172, 255, 0.4)',
  glow: 'rgba(146, 172, 255, 0.6)',
};

// --- MATH HELPERS (Running in JS, not UI Thread) ---

// Simple Cubic Bezier formula
const bezier = (t: number, p0: {x: number, y: number}, p1: {x: number, y: number}, p2: {x: number, y: number}, p3: {x: number, y: number}) => {
  'worklet';
  const cX = 3 * (p1.x - p0.x);
  const bX = 3 * (p2.x - p1.x) - cX;
  const aX = p3.x - p0.x - cX - bX;

  const cY = 3 * (p1.y - p0.y);
  const bY = 3 * (p2.y - p1.y) - cY;
  const aY = p3.y - p0.y - cY - bY;

  const x = (aX * Math.pow(t, 3)) + (bX * Math.pow(t, 2)) + (cX * t) + p0.x;
  const y = (aY * Math.pow(t, 3)) + (bY * Math.pow(t, 2)) + (cY * t) + p0.y;

  return { x, y };
};

/**
 * PRE-CALCULATION ENGINE
 * Generates the SVG path string AND pre-calculates animation frames
 * so the UI thread has zero math work to do.
 */
const generateOptimizedPath = (w: number, h: number, menuCount: number) => {
  const startX = 50;
  const startY = 120;
  const drawerWidth = w;
  
  let d = `M ${startX},${startY}`;
  
  // These arrays will drive the Reanimated interpolation
  // creating a "lookup table" effect.
  const input: number[] = []; // Progress (0 to 1)
  const outputX: number[] = [];
  const outputY: number[] = [];
  const outputAngle: number[] = [];
  
  // Triggers for menu items
  const menuTriggers: { x: number; y: number; trigger: number }[] = []; 

  let prevX = startX;
  let prevY = startY;
  const availableHeight = h - 200;
  const segmentH = availableHeight / menuCount;

  // We will sample the curve to create the animation data
  // Higher samples = smoother motion, Lower samples = less memory. 
  // 40 samples per segment is plenty for smooth animation.
  const SAMPLES_PER_SEGMENT = 40; 
  let globalT = 0;
  const totalSamples = menuCount * SAMPLES_PER_SEGMENT;

  // Use seeded random for consistent path across renders
  const seededRandom = (seed: number) => {
    const x = Math.sin(seed) * 10000;
    return x - Math.floor(x);
  };

  for (let i = 0; i < menuCount; i++) {
    const isEven = i % 2 === 0;
    
    // Geometry Logic - path stays on left side (within first 40% of screen)
    const wave = isEven ? (drawerWidth * 0.08) : (drawerWidth * 0.25);
    const randomX = (seededRandom(i * 42) * 30) - 15;
    const targetX = Math.max(45, Math.min(drawerWidth * 0.35, wave + randomX));
    const targetY = startY + ((i + 1) * segmentH);

    const cp1X = prevX + (targetX - prevX) * 0.5;
    const cp1Y = prevY + (segmentH * 0.8);
    const cp2X = targetX;
    const cp2Y = targetY - (segmentH * 0.5);
    
    // Add Curve to SVG Path with curve intensity
    const intensity = 40;
    const cp1X_adj = cp1X + (isEven ? intensity : -intensity);
    const cp2X_adj = cp2X + (isEven ? -intensity : intensity);

    d += ` C ${cp1X_adj},${cp1Y} ${cp2X_adj},${cp2Y} ${targetX},${targetY}`;

    // --- SAMPLING FOR ANIMATION DATA ---
    const p0 = { x: prevX, y: prevY };
    const p1 = { x: cp1X_adj, y: cp1Y };
    const p2 = { x: cp2X_adj, y: cp2Y };
    const p3 = { x: targetX, y: targetY };

    for (let j = 0; j < SAMPLES_PER_SEGMENT; j++) {
      const t = j / SAMPLES_PER_SEGMENT;
      const point = bezier(t, p0, p1, p2, p3);
      
      // Calculate angle - look slightly ahead for tangent
      const nextT = (j + 1) / SAMPLES_PER_SEGMENT;
      const nextPoint = bezier(nextT, p0, p1, p2, p3);
      const angle = Math.atan2(nextPoint.y - point.y, nextPoint.x - point.x) * (180 / Math.PI) + 90;

      // Add to Arrays
      input.push(globalT / totalSamples);
      outputX.push(point.x);
      outputY.push(point.y);
      outputAngle.push(angle);
      
      globalT++;
    }

    // Save menu item position and trigger time
    menuTriggers.push({
      x: targetX,
      y: targetY,
      trigger: (globalT - 5) / totalSamples // Trigger slightly before segment ends
    });

    prevX = targetX;
    prevY = targetY;
  }

  // Ensure arrays end cleanly
  input.push(1);
  outputX.push(prevX);
  outputY.push(prevY);
  outputAngle.push(outputAngle[outputAngle.length - 1]);

  return {
    d,
    animationData: { input, outputX, outputY, outputAngle },
    menuTriggers
  };
};

const AnimatedPath = Animated.createAnimatedComponent(Path);

// --- Components ---

const SeamlessBackground = memo(() => {
    const player = useVideoPlayer(require('../assets/home-bg.mp4'), (player) => {
        player.loop = true;
        player.play();
        player.muted = true;
    });

    return (
        <View style={StyleSheet.absoluteFill}>
            <VideoView
                style={StyleSheet.absoluteFill}
                player={player}
                contentFit="cover"
                nativeControls={false}
            />
            <View style={[StyleSheet.absoluteFill, { backgroundColor: 'rgba(14, 9, 41, 0.6)' }]} />
        </View>
    );
});

const AnimatedPressable = Animated.createAnimatedComponent(Pressable);

const NavItem = ({
  item,
  onPress,
  disabled,
  index,
  exit,
}: {
  item: typeof NAV_ITEMS[0];
  onPress: (id: string) => void;
  disabled: boolean;
  index: number;
  exit: SharedValue<number>;
}) => {
  const rad = (item.angle - 90) * (Math.PI / 180);
  const ITEM_RADIUS = PLANET_RADIUS + 80; 
  const x = PLANET_CENTER_X + ITEM_RADIUS * Math.cos(rad);
  const y = PLANET_CENTER_Y + ITEM_RADIUS * Math.sin(rad);

  const exitStyle = useAnimatedStyle(() => {
    'worklet';
    const delay = index * 0.08;
    const t = Math.min(1, Math.max(0, (exit.value - delay) / (1 - delay)));
    return {
      opacity: 1 - t,
      transform: [
        { translateY: interpolate(t, [0, 1], [0, 24]) },
        { rotate: `${interpolate(t, [0, 1], [0, -18])}deg` },
        { scale: interpolate(t, [0, 1], [1, 0.7]) },
      ],
    };
  });

  return (
    <AnimatedPressable
      onPress={() => onPress(item.id)}
      disabled={disabled}
      style={[styles.navItem, { left: x - 40, top: y - 40 }, exitStyle]}
    >
      {({ pressed }) => (
        <View style={[styles.navItemInner, pressed && styles.navItemPressed]}>
          <View style={[styles.iconGlass, pressed && styles.iconGlassPressed]}>
            <Ionicons name={item.icon as any} size={22} color={pressed ? '#fff' : THEME.accent} />
          </View>
          <Text style={[styles.navLabel, pressed && styles.navLabelPressed]}>{item.label}</Text>
        </View>
      )}
    </AnimatedPressable>
  );
};

// Subcomponent for Menu Items (Memoized)
const MenuItem = memo(({ 
  data, 
  pos, 
  progress,
  onPress 
}: { 
  data: typeof DRAWER_LINKS[0]; 
  pos: { x: number; y: number; trigger: number }; 
  progress: Animated.SharedValue<number>;
  onPress: (id: string) => void;
}) => {
  const rStyle = useAnimatedStyle(() => {
    'worklet';
    const isVisible = progress.value > pos.trigger;
    return {
      opacity: withTiming(isVisible ? 1 : 0, { duration: 300 }),
      transform: [
        { translateX: withTiming(isVisible ? 24 : 0, { duration: 300 }) },
        { translateY: -20 } // Offset to center
      ]
    };
  });

  return (
    <Animated.View style={[styles.item, { left: pos.x, top: pos.y }, rStyle]}>
      <TouchableOpacity 
        style={styles.itemTouchable} 
        onPress={() => onPress(data.id)}
        activeOpacity={0.7}
      >
        <View style={styles.dot} />
        <View style={styles.itemTextContainer}>
          <Text style={styles.sub} numberOfLines={1}>{data.sub}</Text>
          <Text style={styles.lbl} numberOfLines={1}>{data.label}</Text>
        </View>
      </TouchableOpacity>
    </Animated.View>
  );
});

export default function DashboardScreen() {
  const router = useRouter();
  const insets = useSafeAreaInsets();
  const [isNavigating, setIsNavigating] = useState(false);
  const [isOpen, setIsOpen] = useState(false);

  // Calculate Path Once (useMemo) - runs in JS thread only once
  const { d, animationData, menuTriggers } = useMemo(() => {
    return generateOptimizedPath(width, height, DRAWER_LINKS.length);
  }, []);

  // Shared Values
  const progress = useSharedValue(0);
  const drawerOpacity = useSharedValue(0);
  const menuProgress = useSharedValue(0);
  const navExit = useSharedValue(0);

  useFocusEffect(
    React.useCallback(() => {
      navExit.value = 0;
    }, [navExit])
  );

  const toggleDrawer = () => {
    const nextState = !isOpen;
    setIsOpen(nextState);

    if (nextState) {
      drawerOpacity.value = withTiming(1, { duration: 400 });
      progress.value = withTiming(1, { 
        duration: 2000, 
        easing: Easing.inOut(Easing.cubic) 
      });
      menuProgress.value = withTiming(1, { duration: 300 });
    } else {
      drawerOpacity.value = withTiming(0, { duration: 400 });
      progress.value = withTiming(0, { duration: 400 });
      menuProgress.value = withTiming(0, { duration: 300 });
    }
  };

  const handleNavPress = (id: string) => {
    if (isNavigating) return;
    setIsNavigating(true);
    const routes: any = { events: '/(tabs)/events', schedule: '/(tabs)/schedule', merch: '/(tabs)/merch', stay: '/(tabs)/accommodation', profile: '/(tabs)/profile' };
    navExit.value = withTiming(1, { duration: 520, easing: Easing.inOut(Easing.cubic) });
    setTimeout(() => {
      router.push(routes[id] || '/(tabs)/events');
      setIsNavigating(false);
    }, 520);
  };

  const handleDrawerItemPress = (id: string) => {
    if (isNavigating) return;
    setIsNavigating(true);
    
    // Close the drawer first
    setIsOpen(false);
    drawerOpacity.value = withTiming(0, { duration: 300 });
    progress.value = withTiming(0, { duration: 300 });
    menuProgress.value = withTiming(0, { duration: 300 });
    
    // Route mappings for drawer items
    const drawerRoutes: Record<string, string> = {
      maps: '/maps',
      epc: '/epc-blog',
      hpc: '/hpc-blog',
      sponsors: '/sponsors',
      contact: '/contact',
      developers: '/developers',
    };
    
    setTimeout(() => {
      router.push(drawerRoutes[id] || '/');
      setIsNavigating(false);
    }, 350);
  };

  // 1. Path Drawing Animation (Worklet)
  const pathProps = useAnimatedProps(() => {
    'worklet';
    const len = 2500; 
    return {
      strokeDasharray: [1, 14],
      strokeDashoffset: interpolate(progress.value, [0, 1], [len, 0]),
    };
  });

  // 2. Rocket Movement (Optimized Interpolation using lookup tables)
  const rocketStyle = useAnimatedStyle(() => {
    'worklet';
    // If closed, hide via opacity to save render time
    if (progress.value < 0.01) return { opacity: 0 };
    
    // Native Interpolation using pre-calculated lookup tables (Extremely Fast)
    const tx = interpolate(progress.value, animationData.input, animationData.outputX);
    const ty = interpolate(progress.value, animationData.input, animationData.outputY);
    const rot = interpolate(progress.value, animationData.input, animationData.outputAngle);

    return {
      opacity: 1,
      transform: [
        { translateX: tx - 16 }, 
        { translateY: ty - 16 },
        { rotate: `${rot}deg` }
      ]
    };
  });

  const drawerContainerStyle = useAnimatedStyle(() => {
    'worklet';
    return {
      opacity: drawerOpacity.value,
    };
  });

  const titleExitStyle = useAnimatedStyle(() => {
    'worklet';
    return {
      opacity: interpolate(navExit.value, [0, 1], [1, 0]),
      transform: [
        { translateY: interpolate(navExit.value, [0, 1], [0, -24]) },
        { scale: interpolate(navExit.value, [0, 1], [1, 0.92]) },
      ],
    };
  });

  const toggleExitStyle = useAnimatedStyle(() => {
    'worklet';
    return {
      opacity: interpolate(navExit.value, [0, 1], [1, 0]),
      transform: [
        { translateY: interpolate(navExit.value, [0, 1], [0, -10]) },
        { scale: interpolate(navExit.value, [0, 1], [1, 0.85]) },
      ],
    };
  });

  const topLineStyle = useAnimatedStyle(() => {
    return {
      transform: [
        { translateY: interpolate(menuProgress.value, [0, 1], [-4, 0]) },
        { rotate: `${interpolate(menuProgress.value, [0, 1], [0, 45])}deg` }
      ]
    };
  });

  const bottomLineStyle = useAnimatedStyle(() => {
    return {
      transform: [
        { translateY: interpolate(menuProgress.value, [0, 1], [4, 0]) },
        { rotate: `${interpolate(menuProgress.value, [0, 1], [0, -45])}deg` }
      ]
    };
  });

  return (
    <View style={styles.container}>
      <StatusBar style="light" />

      {/* 1. Background Video */}
      <SeamlessBackground />

      {/* 2. Main Content Layer */}
      <View style={[StyleSheet.absoluteFill, styles.contentLayer]}>
        <Animated.View style={[styles.titleContainer, { marginTop: insets.top + 140 }, titleExitStyle]}>
          <View>
            <Text style={[styles.titleText, styles.titleGlow]}>VERGE</Text>
            <Text style={styles.titleText}>VERGE</Text>
          </View>
          <Text style={styles.subtitleText}>JOURNEY BEYOND</Text>
          <Text style={styles.yearText}>2026</Text>
        </Animated.View>

        {NAV_ITEMS.map((item, index) => (
          <NavItem
            key={item.id}
            item={item}
            onPress={handleNavPress}
            disabled={isNavigating || isOpen}
            index={index}
            exit={navExit}
          />
        ))}
      </View>

      {/* 3. Hamburger Button */}
      <Animated.View style={[styles.navToggle, { top: insets.top + 20 }, toggleExitStyle]}>
        <TouchableOpacity
          onPress={toggleDrawer}
          style={styles.navTogglePressable}
          activeOpacity={0.7}
        >
          <Animated.View style={[styles.navLine, topLineStyle]} />
          <Animated.View style={[styles.navLine, bottomLineStyle]} />
        </TouchableOpacity>
      </Animated.View>

      {/* 4. DRAWER OVERLAY */}
      <Animated.View 
        style={[styles.drawer, drawerContainerStyle]}
        pointerEvents={isOpen ? 'auto' : 'none'}
        renderToHardwareTextureAndroid={true}
      >
        {/* Dark overlay */}
        <View style={styles.drawerOverlay} />

        {/* SVG Layer */}
        <Svg style={StyleSheet.absoluteFill}>
          <Defs>
            <LinearGradient id="pathGrad" x1="0%" y1="0%" x2="0%" y2="100%">
              <Stop offset="0%" stopColor={THEME.path} stopOpacity="0.5" />
              <Stop offset="100%" stopColor={THEME.accent} stopOpacity="0.8" />
            </LinearGradient>
          </Defs>
          <AnimatedPath
            d={d}
            stroke={THEME.dim}
            strokeWidth={2}
            fill="none"
            animatedProps={pathProps}
            strokeLinecap="round" 
          />
        </Svg>

        {/* Rocket */}
        <Animated.View style={[styles.rocket, rocketStyle]}>
          <Svg width={32} height={32} viewBox="0 0 24 24">
            <Defs>
              <LinearGradient id="flameGrad" x1="0%" y1="0%" x2="0%" y2="100%">
                <Stop offset="0%" stopColor="#ff6b35" />
                <Stop offset="100%" stopColor={THEME.accent} />
              </LinearGradient>
            </Defs>
            {/* Rocket Body */}
            <Path 
              d="M12 2L15 8L15 15C15 15 17 17 17 19L12 17L7 19C7 17 9 15 9 15L9 8L12 2Z" 
              fill="white" 
              stroke={THEME.path}
              strokeWidth={0.5}
            />
            {/* Window */}
            <Circle cx="12" cy="10" r="1.5" fill={THEME.bg} />
            {/* Flame */}
            <Path 
              d="M9 15L7 19L5 21L7 22L12 20L17 22L19 21L17 19L15 15" 
              fill="url(#flameGrad)" 
              opacity={0.9} 
            />
          </Svg>
        </Animated.View>

        {/* Menu Items */}
        {menuTriggers.map((pos, i) => (
          <MenuItem 
            key={DRAWER_LINKS[i].id} 
            data={DRAWER_LINKS[i]} 
            pos={pos} 
            progress={progress}
            onPress={handleDrawerItemPress}
          />
        ))}
      </Animated.View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: '#000' },
  contentLayer: { zIndex: 10 },
  
  titleContainer: { alignItems: 'center', width: '100%' },
  titleText: { fontFamily: 'Anurati', fontSize: 52, color: '#FFFFFF', letterSpacing: 18, textAlign: 'center', lineHeight: 70, includeFontPadding: false },
  titleGlow: { position: 'absolute', top: 0, left: 0, right: 0, fontFamily: 'Anurati', color: THEME.accent, opacity: 0.4, textShadowColor: THEME.accent, textShadowOffset: { width: 0, height: 0 }, textShadowRadius: 40, lineHeight: 70, includeFontPadding: false },
  subtitleText: { fontFamily: 'Orbitron_400Regular', fontSize: 11, color: THEME.accent, letterSpacing: 14, marginTop: 16, opacity: 0.7, textTransform: 'uppercase' },
  yearText: { fontFamily: 'Orbitron_700Bold', fontSize: 14, color: THEME.dim, letterSpacing: 8, marginTop: 8, opacity: 0.5 },

  navItem: { position: 'absolute', width: 80, height: 80, alignItems: 'center', justifyContent: 'center', zIndex: 30 },
  navItemInner: { alignItems: 'center', justifyContent: 'center' },
  iconGlass: { 
    width: 52, 
    height: 52, 
    borderRadius: 26, 
    backgroundColor: 'rgba(14, 9, 41, 0.6)', 
    borderWidth: 1, 
    borderColor: 'rgba(146, 172, 255, 0.25)', 
    alignItems: 'center', 
    justifyContent: 'center', 
    marginBottom: 8, 
    shadowColor: THEME.accent, 
    shadowOffset: { width: 0, height: 0 }, 
    shadowOpacity: 0.3, 
    shadowRadius: 12 
  },
  iconGlassPressed: {
    backgroundColor: 'rgba(146, 172, 255, 0.2)',
    borderColor: THEME.accent,
  },
  navItemPressed: { transform: [{ scale: 0.95 }] },
  navLabel: { color: 'rgba(255, 255, 255, 0.8)', fontSize: 10, fontWeight: '600', letterSpacing: 1, textAlign: 'center', textShadowColor: 'rgba(0,0,0,0.9)', textShadowRadius: 4 },
  navLabelPressed: { color: THEME.accent },

  navToggle: { position: 'absolute', left: 24, width: 40, height: 40, zIndex: 300 },
  navTogglePressable: { flex: 1, alignItems: 'center', justifyContent: 'center' },
  navLine: { width: 26, height: 2, backgroundColor: '#FFFFFF', borderRadius: 2, position: 'absolute' },

  drawer: { ...StyleSheet.absoluteFillObject, zIndex: 200 },
  drawerOverlay: { ...StyleSheet.absoluteFillObject, backgroundColor: 'rgba(14, 9, 41, 0.97)' },
  
  // Rocket
  rocket: {
    position: 'absolute', 
    top: 0, 
    left: 0, 
    width: 32, 
    height: 32,
    zIndex: 25,
  },

  // Menu Items
  item: { 
    position: 'absolute', 
    zIndex: 30,
    right: 20,
  },
  itemTouchable: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 8,
    paddingHorizontal: 4,
  },
  itemTextContainer: {
    flex: 1,
    minWidth: 200,
  },
  dot: { 
    width: 8, 
    height: 8, 
    borderRadius: 4, 
    backgroundColor: THEME.accent, 
    marginRight: 12, 
    marginLeft: -30,
    shadowColor: THEME.accent,
    shadowOffset: { width: 0, height: 0 },
    shadowOpacity: 0.8,
    shadowRadius: 6,
  },
  lbl: { 
    color: 'white', 
    fontSize: 18, 
    fontFamily: 'Orbitron_400Regular',
    letterSpacing: 1, 
    textTransform: 'uppercase',
  },
  sub: { 
    color: THEME.dim, 
    fontSize: 10, 
    fontFamily: 'Orbitron_400Regular',
    letterSpacing: 3,
    marginBottom: 2,
  },
});
